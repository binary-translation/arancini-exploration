#include "arancini/ir/node.h"
#include "arancini/ir/port.h"
#include "arancini/output/static/llvm/Passes/RegArgPromotionPass.h"
#include <arancini/output/static/llvm/llvm-static-output-engine-impl.h>
#include <arancini/output/static/llvm/llvm-static-output-engine.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/NoFolder.h>
#include <llvm/Transforms/Utils/Cloning.h>
#include <map>
#include <unordered_set>

namespace arancini::output::o_static::llvm {
    using namespace arancini::ir;
    using namespace ::llvm;

    static const char *regnames[] = {
#define DEFREG(ctype, ltype, name) "" #name,

#include <arancini/input/x86/reg.def>

#undef DEFREG
    };

    static std::string reg_name(size_t regidx) {
        if ((size_t) regidx < (sizeof(regnames) / sizeof(regnames[0]))) {
            return regnames[regidx];
        }

        return "guestreg";
    }

    /**
     * Get the register idx if addr is a GEP
     * @param addr
     * @param regIdx
     * @return true/false
     */
    static std::optional<size_t> getRegisterIdx(Value *addr, const Value *cpuStruct) {
        const auto GEP = dyn_cast<GetElementPtrInst>(addr);
        if (GEP == nullptr || GEP->getNumIndices() != 2 || GEP->getOperand(0) != cpuStruct) {
            return std::nullopt;
        }
        const auto *idx0 = dyn_cast<ConstantInt>(GEP->getOperand(1));
        const auto *idx1 = dyn_cast<ConstantInt>(GEP->getOperand(2));

        if (idx0 == nullptr || idx1 == nullptr || idx0->getValue().getZExtValue() != 0) {
            return std::nullopt;
        }

        return idx1->getValue().getZExtValue();
    }

    /**
     * Check if the address is a GEP and points at the register regIdx
     * @param Addr
     * @param regIdx
     * @return true/false
     */
    static bool isRegAddr(Value *addr, const Value *cpuStruct, size_t regIdx) {
        const auto addrIdx = getRegisterIdx(addr, cpuStruct);

        return addrIdx.has_value() && *addrIdx == regIdx;
    }

    static bool shouldRecoverFunctionSignature(const Function *F) {
        // then we also need to check that we are currently looking at a function generated by our translator
        // for this, we check whether the arancini attribute is set.
        return F->hasFnAttribute(ARANCINI_FUNCTION_TYPE) &&
               F->getFnAttribute(ARANCINI_FUNCTION_TYPE).getValueAsString() == ARANCINI_STATIC_FUNCTION;
    }

    Function *RegArgPromotionPass::promoteRegToArg(Function *F) {
        const size_t MAX_GPR_IDX = 16;

        if (!shouldRecoverFunctionSignature(F)) {
            return nullptr;
        }

        auto argumentRegisters = promotedRegs.find(F);
        std::set<size_t> newArgRegs{};

        // we need to check for reads from registers -- if the register is read but not dominated by a write,
        // then we add the register to the function arguments.
        // After that, we check all call sites and update the calls accordingly.

        // The high-level algorithm is as follows:
        // - start a bfs search from the entry block.
        // - If we encounter a read from a register, we add the register (and all registers before it in the calling conv)
        //   as arguments.
        // - If we encounter a write to a register, we discard the current branch
        // Then, we update all call-sites to pass the register as an argument. The loads in the function are replaced
        // with the arguments.


        // all reads from registers are of the form `gep 0 idx`, where `idx` is the register number as defined in reg.def.
        assert(F->arg_size() >= 1 && "Expected more than one arg");
        auto cpuStructPtr = F->getArg(0);

        // the queue contains the block and the argument candidate registers
        std::deque<std::pair<BasicBlock *, std::unordered_set<size_t>>> queue;
        std::unordered_set<BasicBlock *> seen;
        std::vector<LoadInst *> nonDominatedLoads;
        std::unordered_set<size_t> arg_regs{};
        if (argumentRegisters != promotedRegs.end()) {
            // maybe inefficient to copy here
            arg_regs = argumentRegisters->second;
        }
        queue.emplace_back(&F->getEntryBlock(), arg_regs);

        while (!queue.empty()) {
            auto [block, dom_stores] = *queue.begin();
            queue.pop_front();
            if (!seen.insert(block).second) {
                continue;
            }

            for (auto &I: *block) {
                if (const auto loadInst = dyn_cast<LoadInst>(&I)) {
                    const auto regIdx = getRegisterIdx(loadInst->getPointerOperand(), cpuStructPtr);
                    if (!regIdx.has_value()) {
                        continue;
                    }

                    if (dom_stores.find(*regIdx) != dom_stores.end()) {
                        // we have seen a dominating store or the register has already been promoted to an argument
                        continue;
                    }

                    if (*regIdx == 0 || *regIdx > MAX_GPR_IDX) {
                        // for now, we only consider GPRs
                        continue;
                    }

                    newArgRegs.emplace(*regIdx);
                    nonDominatedLoads.emplace_back(loadInst);
                } else if (const auto storeInst = dyn_cast<StoreInst>(&I)) {
                    const auto regIdx = getRegisterIdx(storeInst->getPointerOperand(), cpuStructPtr);
                    if (!regIdx.has_value()) {
                        continue;
                    }

                    dom_stores.emplace(*regIdx);
                }
            }

            // now insert all successors into the worklist
            for (auto *succ: successors(block)) {
                queue.emplace_back(succ, dom_stores);
            }
        }

        if (newArgRegs.empty()) {
            // no new argument registers discovered
            return nullptr;
        }
        // since we have new argument registers, we replace the entry in promotedRegs
        arg_regs.insert(newArgRegs.begin(), newArgRegs.end());
        if (argumentRegisters != promotedRegs.end()) {
            promotedRegs.erase(argumentRegisters);
        }


        const auto i64Ty = Type::getInt64Ty(F->getContext());
        const auto i32Ty = Type::getInt32Ty(F->getContext());

        // Now we add each argument to the function and replace reads from the reg.
        // Since it is not possible to add arguments to LLVM functions, we first create a new function with
        // the updated signature.
        std::vector<Type *> params = {};
        for (const auto &arg : F->args()) {
            params.emplace_back(arg.getType());
        }
        for (size_t i = 0; i < newArgRegs.size(); ++i) {
            // TODO: needs to be updated once we support more than just GPRs
            params.emplace_back(i64Ty);
        }
        FunctionType *signature = FunctionType::get(F->getReturnType(), params, false);
        Function *newFunc = Function::Create(signature, F->getLinkage());
        newFunc->copyAttributesFrom(F);
        newFunc->copyMetadata(F, 0);
        // TODO: copy attributes from other
        newFunc->addParamAttr(0, Attribute::AttrKind::NoCapture);
        newFunc->addParamAttr(0, Attribute::AttrKind::NoAlias);
        newFunc->addParamAttr(0, Attribute::AttrKind::NoUndef);

        F->setSubprogram(nullptr);

        F->getParent()->getFunctionList().insert(F->getIterator(), newFunc);
        newFunc->takeName(F);

        // updating all callers
        SmallVector<Value *, 16> Args;
        while (!F->use_empty()) {
            CallBase &CB = cast<CallBase>(*F->user_back());
            assert(CB.getCalledFunction() == F);
            IRBuilder<NoFolder> IRB(&CB);

            // now we need to insert loads from the register struct and create a new call
            assert(CB.getParent()->getParent()->arg_size() >= 1);

            for (const auto &Arg : CB.args()) {
                Args.emplace_back(Arg.get());
            }

            for (const auto regIdx : newArgRegs) {
                // For now, we only handle 64 bit registers.
                const auto ptr = IRB.CreateGEP(
                        this->cpuStateType, CB.getParent()->getParent()->getArg(0),
                        {ConstantInt::get(i64Ty, 0), ConstantInt::get(i32Ty, regIdx)}, reg_name(regIdx));
                Args.emplace_back(IRB.CreateLoad(i64Ty, ptr));
            }

            SmallVector<OperandBundleDef, 1> opBundles;
            CB.getOperandBundlesAsDefs(opBundles);
            auto *newCall = CallInst::Create(newFunc, Args, opBundles, "", &CB);
            newCall->setCallingConv(CB.getCallingConv());

            if (!CB.use_empty()) {
                CB.replaceAllUsesWith(newCall);
                newCall->takeName(&CB);
            }

            // remove old call
            CB.eraseFromParent();
            Args.clear();
        }

        // now we can splice the old body into the new function
        newFunc->splice(newFunc->begin(), F);

        // now move over the uses of the cpu struct
        auto newArgIter = newFunc->arg_begin();
        for (auto &Arg: F->args()) {
            Arg.replaceAllUsesWith(&*newArgIter);
            newArgIter->takeName(&Arg);
            ++newArgIter;
        }

        cpuStructPtr = newFunc->getArg(0);
        // TODO: now we need to replace all loads not dominated by stores with the argument.
        for (const auto loadInst: nonDominatedLoads) {
            const auto regIdx = getRegisterIdx(loadInst->getPointerOperand(), cpuStructPtr);
            assert(regIdx.has_value());
            // Now we just replace the loadInst with the argument.
            // TODO: probably replace with std::set instead of std::unordered_set?
            auto it = newArgRegs.find(*regIdx);
            assert(it != newArgRegs.end());
            const auto argIdx = std::distance(newArgRegs.begin(), it) + 1;
            Value *arg = newFunc->getArg(argIdx);

            if (loadInst->getType() != arg->getType()) {
                assert(loadInst->getType()->getPrimitiveSizeInBits() < arg->getType()->getPrimitiveSizeInBits());
                arg = CastInst::CreateTruncOrBitCast(arg, loadInst->getType(), "", loadInst);
            }

            loadInst->replaceAllUsesWith(arg);
            loadInst->eraseFromParent();
        }

        // Finally, update promotedRegs
        promotedRegs.emplace(newFunc, arg_regs);

        return newFunc;
    }


    PreservedAnalyses RegArgPromotionPass::run(LazyCallGraph::SCC &C, CGSCCAnalysisManager &AM, LazyCallGraph &CG,
                                               CGSCCUpdateResult &UR) {
        bool Changed = false, LocalChange;

        // Iterate until we stop promoting from this SCC.
        do {
            LocalChange = false;

            FunctionAnalysisManager &FAM =
                    AM.getResult<FunctionAnalysisManagerCGSCCProxy>(C, CG).getManager();

            bool IsRecursive = C.size() > 1;
            for (LazyCallGraph::Node &N: C) {
                Function &OldF = N.getFunction();
                Function *NewF = promoteRegToArg(&OldF/*, FAM, MaxElements, IsRecursive*/);
                if (!NewF)
                    continue;
                LocalChange = true;

                // Directly substitute the functions in the call graph. Note that this
                // requires the old function to be completely dead and completely
                // replaced by the new function. It does no call graph updates, it merely
                // swaps out the particular function mapped to a particular node in the
                // graph.
                C.getOuterRefSCC().replaceNodeFunction(N, *NewF);
                FAM.clear(OldF, OldF.getName());
                OldF.eraseFromParent();

                PreservedAnalyses FuncPA;
                FuncPA.preserveSet<CFGAnalyses>();
                for (auto *U: NewF->users()) {
                    auto *UserF = cast<CallBase>(U)->getFunction();
                    FAM.invalidate(*UserF, FuncPA);
                }
            }

            Changed |= LocalChange;
        } while (LocalChange);

        if (!Changed)
            return PreservedAnalyses::all();

        PreservedAnalyses PA;
        // We've cleared out analyses for deleted functions.
        PA.preserve<FunctionAnalysisManagerCGSCCProxy>();
        // We've manually invalidated analyses for functions we've modified.
        PA.preserveSet<AllAnalysesOn<Function>>();
        return PA;
    }
}
