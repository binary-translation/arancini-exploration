#include "arancini/ir/node.h"
#include "arancini/ir/port.h"
#include "arancini/output/static/llvm/Passes/RegArgPromotionPass.h"
#include <arancini/output/static/llvm/llvm-static-output-engine-impl.h>
#include <arancini/output/static/llvm/llvm-static-output-engine.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/NoFolder.h>
#include <llvm/Transforms/Utils/Cloning.h>
#include <map>
#include <unordered_set>

namespace arancini::output::o_static::llvm {
    using namespace arancini::ir;
    using namespace ::llvm;

    static const char *regnames[] = {
#define DEFREG(ctype, ltype, name) "" #name,

#include <arancini/input/x86/reg.def>

#undef DEFREG
    };

    static std::string reg_name(int regidx) {
        if ((size_t) regidx < (sizeof(regnames) / sizeof(regnames[0]))) {
            return regnames[regidx];
        }

        return "guestreg";
    }

    /**
     * Get the register idx if addr is a GEP
     * @param addr
     * @param regIdx
     * @return true/false
     */
    static std::optional<size_t> getRegisterIdx(Value *addr, const Value *cpuStruct) {
        const auto GEP = dyn_cast<GetElementPtrInst>(addr);
        if (GEP == nullptr || GEP->getNumIndices() != 2 || GEP->getOperand(0) != cpuStruct) {
            return std::nullopt;
        }
        const auto *idx0 = dyn_cast<ConstantInt>(GEP->getOperand(1));
        const auto *idx1 = dyn_cast<ConstantInt>(GEP->getOperand(2));

        if (idx0 == nullptr || idx1 == nullptr || idx0->getValue().getZExtValue() != 0) {
            return std::nullopt;
        }

        return idx1->getValue().getZExtValue();
    }

    /**
     * Check if the address is a GEP and points at the register regIdx
     * @param Addr
     * @param regIdx
     * @return true/false
     */
    static bool isRegAddr(Value *addr, const Value *cpuStruct, size_t regIdx) {
        const auto addrIdx = getRegisterIdx(addr, cpuStruct);

        return addrIdx.has_value() && *addrIdx == regIdx;
    }

    static bool shouldRecoverFunctionSignature(const Function *F) {
        // for now, only do this optimization for functions that do not call other generated functions
        for (auto &BB: *F) {
            for (auto &I: BB) {
                if (auto *callInst = dyn_cast<CallInst>(&I); callInst != nullptr &&
                                                             callInst->getCalledFunction()->getName() != "MainLoop") {
                    return false;
                }
            }
        }

        // then we also need to check that we are currently looking at a function generated by our translator
        // for this, we check whether the arancini attribute is set.
        return F->hasFnAttribute(ARANCINI_FUNCTION_TYPE) &&
               F->getFnAttribute(ARANCINI_FUNCTION_TYPE).getValueAsString() == ARANCINI_STATIC_FUNCTION;
    }

    Function *RegArgPromotionPass::promoteRegToArg(Function *F) {
        // TODO: instead of hardcoding, take form reg.def
        const std::vector<size_t> indices = {
                8, /* RDI */
                7, /* RSI */
                3, /* RDX */
                2, /* RCX */
                9, /* R8 */
                10, /* R9 */
        };

        if (!shouldRecoverFunctionSignature(F)) {
            return nullptr;
        }

        size_t argRegs = 0;

        // we need to check for reads from registers -- if the register is read but not dominated by a write,
        // then we add the register to the function arguments.
        // After that, we check all call sites and update the calls accordingly.

        // The high-level algorithm is as follows:
        // - start a bfs search from the entry block.
        // - If we encounter a read from a register, we add the register (and all registers before it in the calling conv)
        //   as arguments.
        // - If we encounter a write to a register, we discard the current branch
        // Then, we update all call-sites to pass the register as an argument. The loads in the function are replaced
        // with the arguments.


        // all reads from registers are of the form `gep 0 idx`, where `idx` is the register number as defined in reg.def.
        assert(F->arg_size() >= 1 && "Expected more than one arg");
        auto cpuStructPtr = F->getArg(0);

        // the queue contains the block and the argument candidate registers
        std::deque<std::pair<::llvm::BasicBlock *, std::vector<std::pair<size_t, size_t>>>> queue;
        std::unordered_set<BasicBlock *> seen;
        std::vector<LoadInst *> nonDominatedLoads;
        std::vector<std::pair<size_t, size_t>> worklist{};
        size_t i = 0;
        for (auto it = indices.begin(); it != indices.end(); ++it) {
            worklist.emplace_back(*it, i++);
        }
        queue.emplace_back(&F->getEntryBlock(), worklist);

        while (!queue.empty()) {
            auto [block, regs] = *queue.begin();
            queue.pop_front();
            if (!seen.insert(block).second) {
                continue;
            }

            for (auto &I: *block) {
                if (const auto loadInst = dyn_cast<LoadInst>(&I)) {
                    for (auto regIter = regs.begin(); regIter != regs.end();) {
                        // if we see a load from regIter, all registers below it are considered arguments.
                        const auto reg = regIter->first;
                        const auto regIndex = regIter->second;
                        if (isRegAddr(loadInst->getPointerOperand(), cpuStructPtr, reg)) {
                            nonDominatedLoads.emplace_back(loadInst);
                            argRegs = std::max(argRegs, regIndex + 1);
                            // now remove everything up to regIter in regs
                            regIter = regs.erase(regs.begin(), regIter + 1);
                        } else {
                            ++regIter;
                        }
                    }
                } else if (const auto storeInst = dyn_cast<StoreInst>(&I)) {
                    for (auto reg = regs.begin(); reg != regs.end();) {
                        // if we see a store to a register, it is not considered an argument in this branch
                        if (isRegAddr(storeInst->getPointerOperand(), cpuStructPtr, reg->first)) {
                            reg = regs.erase(reg);
                        } else {
                            ++reg;
                        }
                    }
                }
            }

            // now insert all predecessors into the worklist
            for (auto *succ: successors(block)) {
                queue.emplace_back(succ, regs);
            }
        }

        if (argRegs <= F->arg_size()) {
            return nullptr;
        }

        const auto i64Ty = Type::getInt64Ty(F->getContext());
        const auto i32Ty = Type::getInt32Ty(F->getContext());

        // now we add each argument to the function and replace reads from the reg
        // since it is not possible to add arguments to LLVM functions, we first create a new function with
        // the updated signature.
        std::vector<Type *> params = {F->getArg(0)->getType()};
        for (size_t i = 0; i < argRegs; ++i) {
            // TODO: get this from regs.def
            params.emplace_back(i64Ty);
        }
        FunctionType *signature = FunctionType::get(F->getReturnType(), params, false);
        Function *newFunc = Function::Create(signature, F->getLinkage());
        newFunc->copyAttributesFrom(F);
        newFunc->copyMetadata(F, 0);
        // TODO: copy attributes from other
        newFunc->addParamAttr(0, Attribute::AttrKind::NoCapture);
        newFunc->addParamAttr(0, Attribute::AttrKind::NoAlias);
        newFunc->addParamAttr(0, Attribute::AttrKind::NoUndef);

        F->setSubprogram(nullptr);

        F->getParent()->getFunctionList().insert(F->getIterator(), newFunc);
        newFunc->takeName(F);

        // updating all callers
        SmallVector<Value *, 16> Args;
        while (!F->use_empty()) {
            CallBase &CB = cast<CallBase>(*F->user_back());
            assert(CB.getCalledFunction() == F);
            IRBuilder<NoFolder> IRB(&CB);

            // now we need to insert loads from the register struct and create a new call
            assert(CB.getParent()->getParent()->arg_size() >= 1);
            Value *cpuStructPtr = CB.getParent()->getParent()->getArg(0);

            Args.emplace_back(cpuStructPtr);

            for (size_t i = 0; i < argRegs; ++i) {
                const auto regIdx = indices[i];
                // for now, we only handle 64 bit registers
                const auto ptr = IRB.CreateGEP(
                        this->cpuStateType, cpuStructPtr,
                        {ConstantInt::get(i64Ty, 0), ConstantInt::get(i32Ty, regIdx)}, reg_name(regIdx));
                Args.emplace_back(IRB.CreateLoad(i64Ty, ptr));
            }

            SmallVector<OperandBundleDef, 1> opBundles;
            CB.getOperandBundlesAsDefs(opBundles);
            auto *newCall = CallInst::Create(newFunc, Args, opBundles, "", &CB);
            newCall->setCallingConv(CB.getCallingConv());

            if (!CB.use_empty()) {
                CB.replaceAllUsesWith(newCall);
                newCall->takeName(&CB);
            }

            // remove old call
            CB.eraseFromParent();
            Args.clear();
        }

        // now we can splice the old body into the new function
        newFunc->splice(newFunc->begin(), F);

        // now move over the uses of the cpu struct
        auto newArgIter = newFunc->arg_begin();
        for (auto &Arg: F->args()) {
            Arg.replaceAllUsesWith(&*newArgIter);
            newArgIter->takeName(&Arg);
            ++newArgIter;
        }

        cpuStructPtr = newFunc->getArg(0);
        // TODO: now we need to replace all loads not dominated by stores with the argument.
        for (const auto loadInst: nonDominatedLoads) {
            const auto regIdx = getRegisterIdx(loadInst->getPointerOperand(), cpuStructPtr);
            assert(regIdx.has_value());
            // now we just replace the loadInst with the argument.
            auto it = std::find(indices.begin(), indices.end(), *regIdx);
            assert(it != indices.end());
            const auto argIdx = std::distance(indices.begin(), it) + 1;
            Value *arg = newFunc->getArg(argIdx);

            if (loadInst->getType() != arg->getType()) {
                assert(loadInst->getType()->getPrimitiveSizeInBits() < arg->getType()->getPrimitiveSizeInBits());
                arg = CastInst::CreateTruncOrBitCast(arg, loadInst->getType(), "", loadInst);
            }

            loadInst->replaceAllUsesWith(arg);
            loadInst->eraseFromParent();
        }

        return newFunc;
    }


    PreservedAnalyses RegArgPromotionPass::run(LazyCallGraph::SCC &C, CGSCCAnalysisManager &AM, LazyCallGraph &CG,
                                               CGSCCUpdateResult &UR) {
        bool Changed = false, LocalChange;

        // Iterate until we stop promoting from this SCC.
        do {
            LocalChange = false;

            FunctionAnalysisManager &FAM =
                    AM.getResult<FunctionAnalysisManagerCGSCCProxy>(C, CG).getManager();

            bool IsRecursive = C.size() > 1;
            for (LazyCallGraph::Node &N: C) {
                Function &OldF = N.getFunction();
                Function *NewF = promoteRegToArg(&OldF/*, FAM, MaxElements, IsRecursive*/);
                if (!NewF)
                    continue;
                LocalChange = true;

                // Directly substitute the functions in the call graph. Note that this
                // requires the old function to be completely dead and completely
                // replaced by the new function. It does no call graph updates, it merely
                // swaps out the particular function mapped to a particular node in the
                // graph.
                C.getOuterRefSCC().replaceNodeFunction(N, *NewF);
                FAM.clear(OldF, OldF.getName());
                OldF.eraseFromParent();

                PreservedAnalyses FuncPA;
                FuncPA.preserveSet<CFGAnalyses>();
                for (auto *U: NewF->users()) {
                    auto *UserF = cast<CallBase>(U)->getFunction();
                    FAM.invalidate(*UserF, FuncPA);
                }
            }

            Changed |= LocalChange;
        } while (LocalChange);

        if (!Changed)
            return PreservedAnalyses::all();

        PreservedAnalyses PA;
        // We've cleared out analyses for deleted functions.
        PA.preserve<FunctionAnalysisManagerCGSCCProxy>();
        // We've manually invalidated analyses for functions we've modified.
        PA.preserveSet<AllAnalysesOn<Function>>();
        return PA;
    }
}
